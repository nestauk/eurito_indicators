<script context='module'>
	import * as _ from 'lamb';

	const makeBuildCycleIndex = (direction) => _.pipe([
		_.collect([
			_.identity,
			_.rotateBy(direction)
		]),
		_.apply(_.make)
	]);

	const makeCycleUsing = (cycle, getValue, setValue, wrap = false) => {
		const nextInCycle = makeBuildCycleIndex(-1)(cycle);
		const prevInCycle = makeBuildCycleIndex(1)(cycle);
		if (!wrap) {
			nextInCycle[cycle[cycle.length-1]] = null;
			prevInCycle[cycle[0]] = null;
		}
		const peekNext = () => {
			const value = getValue();
			return _.isNil(value)
				? cycle[0]
				: nextInCycle[value];
		};
		const peekPrev = () => {
			const value = getValue();
			return _.isNil(value)
				? cycle[0]
				: prevInCycle[value];
		};
		const cycler = {
			peekNext,
			peekPrev,
			next: () => {
				const next = peekNext();
				if (_.isNil(next)) {
					return;
				}
				setValue(next);
			},
			prev: () => {
				const prev = peekPrev();
				if (_.isNil(prev)) {
					return;
				}
				setValue(prev);
			}
		};
		!(getValue() in nextInCycle) && cycler.next();
		return cycler;
	};

	const makeCycleUsingAndStore = (cycle, store, wrap = false) => makeCycleUsing(
		cycle,
		() => get(store), 
		value => store.set(value),
		wrap
	);

	const makeCycleUsingAndStoreProp = (cycle, store, prop, wrap = false) => makeCycleUsing(
		cycle,
		() => get(store)[prop],
		value => {
			const options = get(store);
			options[prop] = value;
			store.set(options);
		},
		wrap
	);
</script>

<script>
	import {writable, get} from 'svelte/store';
	import {
		fontFamily, 
		fontScaling, 
		// fontVariationSettings,
		letterSpacing,
		wordSpacing,
		lineHeight
	} from 'app/stores/font';

	import {colorCorrectionOptions} from 'app/stores/color';

	// Accesibility menu options
	const properties = [
		'typeface',
		'fontScaling',
		'lineHeight',
		'letterSpacing',
		'wordSpacing',
		// 'width',
		// 'weight',
		'invert',
		'colorModel',
		'hue',
		'grayscale',
		'brightness',
		'contrast'
	];

	// Fonts and Text
	const fonts = [
		'Archivo',
		'Avenir Next Variable',
		'Noboto Flex',
		'Open Dyslexia'
	];
	const fontScales = [0.5, 0.75, 1, 1.25, 1.5];
	const lineHeights = [1, 1.25, 1.5, 1.75, 2];
	const letterSpacings = [0, .1, .2];
	const wordSpacings = [0, .2, .4];

	const simulations = ['none', 'protanopia', 'deuteranopia', 'tritanopia'];
	const colorModels = ['identity', 'protanopia', 'deuteranopia', 'tritanopia'];

	const selectedProperty = writable(null);
	const propsCycler = makeCycleUsingAndStore(properties, selectedProperty);

	const config = {
		typeface: {
			label: 'Font'
		},
		fontScaling: {
			label: 'Font scale'
		},
		lineHeight: {
			label: 'Line height'
		},
		letterSpacing: {
			label: 'Letter spacing'
		},
		wordSpacing: {
			label: 'Word spacing'
		},
		/*
			width: {label: 'Font width'
		},
			weight: {label: 'Font weight'
		},
		*/
		invert: {
			label: 'Invert'
		},
		colorModel: {
			label: 'Color deficiency'
		},
		hue: {
			label: 'Hue shift'
		},
		grayscale: {
			label: 'Grayscale'
		},
		brightness: {
			label: 'Brightness'
		},
		contrast: {
			label: 'Contrast'
		}
	};


	/*
	let variationsEnabled = true;
	let fontVariationsCycler = {
		next: _.mapValues(fontVariations, makeBuildCycleIndex(-1)),
		prev: _.mapValues(fontVariations, makeBuildCycleIndex(1))
	}
	*/

	/*
	const cycleVariation = () => {
		if (!variationsEnabled) {
			return;
		}
		const fontName = get(fontFamily);
		const nextSettings =  fontVariationsCycler[fontName][get(fontVariationSettings)]
			|| fontVariations[fontName][0];
		fontVariationSettings.set(nextSettings);
	}
	*/

	const cycleFont = makeCycleUsing(
		fonts,
		() => get(fontFamily),
		value => {
			fontFamily.set(value);
			/*
			variationsEnabled = value in fontVariations;
			fontVariationSettings.set('');
			cycleVariation.next();
			*/
		}
	);

	const cycleSize = makeCycleUsingAndStore(fontScales, fontScaling);
	const cycleLineHeight = makeCycleUsingAndStore(lineHeights, lineHeight);
	const cycleLetterSpacing = makeCycleUsingAndStore(
		letterSpacings,
		letterSpacing
	);
	const cycleWordSpacing = makeCycleUsingAndStore(
		wordSpacings,
		wordSpacing
	);
	const cycleColorModels = makeCycleUsingAndStoreProp(
		colorModels,
		colorCorrectionOptions,
		'colorModel'
	);
	const cycleSimulations = makeCycleUsingAndStoreProp(
		simulations,
		colorCorrectionOptions,
		'simulate'
	);


	const toggleActive = () => {
		const ccOptions = get(colorCorrectionOptions);
		ccOptions.active = !ccOptions.active;
		colorCorrectionOptions.set(ccOptions);
	}
	const cycleHues = () => {
		const ccOptions = get(colorCorrectionOptions);
		ccOptions.hue = nextHues[ccOptions.hue] || hues[0];
		colorCorrectionOptions.set(ccOptions);
	}
	const cycleGrayscales = () => {
		const ccOptions = get(colorCorrectionOptions);
		ccOptions.grayscale = nextGrayscales[ccOptions.contrast] || contrasts[0];
		colorCorrectionOptions.set(ccOptions);
	}
	const cycleBrightnesses = () => {
		const ccOptions = get(colorCorrectionOptions);
		ccOptions.grayscale = nextGrayscales[ccOptions.contrast] || contrasts[0];
		colorCorrectionOptions.set(ccOptions);
	}
	const cycleContrasts = () => {
		const ccOptions = get(colorCorrectionOptions);
		ccOptions.grayscale = nextGrayscales[ccOptions.contrast] || contrasts[0];
		colorCorrectionOptions.set(ccOptions);
	}
	const cycleInverts = () => {
		const ccOptions = get(colorCorrectionOptions);
		ccOptions.grayscale = nextGrayscales[ccOptions.contrast] || contrasts[0];
		colorCorrectionOptions.set(ccOptions);
	}
	*/

	let hasNextProp, hasPrevProp;
	$: $selectedProperty, hasNextProp = !propsCycler.peekNext();
	$: $selectedProperty, hasPrevProp = !propsCycler.peekPrev();	
</script>

<section>
	<header>
		<out class='text'>T</out>
		<out class='color'>C</out>
	</header>
	<menu>
		{#if $selectedProperty === 'typeface'}
			<label>{config[$selectedProperty].label}: {$fontFamily}</label>
			<div class='layout-1'>
				{#each fonts as font}
					<input type="radio" bind:group={$fontFamily} value={font}>
				{/each}
			</div>
		{:else if $selectedProperty === 'fontScaling'}
			<label>{config[$selectedProperty].label}: {Math.round($fontScaling*100)}%</label>
			<div class='layout-2'>
				{#each fontScales as scale}
					<div class='.layout-2'>
						<label>{Math.round(scale * 100)}%</label>
						<input type="radio" bind:group={$fontScaling} value={scale}>
					</div>
				{/each}
			</div>
			{:else if $selectedProperty === 'lineHeight'}
			<label>{config[$selectedProperty].label}: {Math.round($lineHeight*100)}%</label>
			<div class='layout-2'>
				{#each lineHeights as height}
					<div class='.layout-2'>
						<label>{Math.round(height * 100)}%</label>
						<input type="radio" bind:group={$lineHeight} value={height}>
					</div>
				{/each}
			</div>
			{:else if $selectedProperty === 'letterSpacing'}
			<label>{config[$selectedProperty].label}: {Math.round($letterSpacing*100)}%</label>
			<div class='layout-2'>
				{#each letterSpacings as spacing}
					<div class='.layout-2'>
						<label>{Math.round(spacing * 100)}%</label>
						<input type="radio" bind:group={$letterSpacing} value={spacing}>
					</div>
				{/each}
			</div>
			{:else if $selectedProperty === 'wordSpacing'}
			<label>{config[$selectedProperty].label}: {Math.round($wordSpacing*100)}%</label>
			<div class='layout-2'>
				{#each wordSpacings as spacing}
					<div class='.layout-2'>
						<label>{Math.round(spacing * 100)}%</label>
						<input type="radio" bind:group={$wordSpacing} value={spacing}>
					</div>
				{/each}
			</div>
		{:else}
			<label>{config[$selectedProperty].label}</label>
		{/if}
	</menu>
	<nav>
		<button disabled={hasPrevProp} on:click={propsCycler.prev}>&leftarrow;</button>
		<button disabled={hasNextProp} on:click={propsCycler.next}>&rightarrow;</button>
	</nav>
</section>

<style>
	section {
		display: grid;
		position: absolute;
		bottom: var(--dim-header-height);
		left: 0;
		width: 100%;
		height: 4.5rem;
		background: white;
		border: thin solid black;
		z-index: 1;
		grid-template-areas: "indicators proppanel nav";
		grid-template-columns: min-content 1fr min-content;
	}
	button {
		display: block;
	}
	header {
		font-family: sans-serif;
		font-size: 16px;
		display: grid;
		grid-template-areas: "upper" "lower";
		grid-template-rows: 50% 50%;
	}
	nav {
		display: grid;
		grid-template-areas: "upper" "lower";
		grid-template-rows: 50% 50%;
	}
	label {
		display: block;
		text-align: center;
	}

	.layout-1, .layout-2 {
		display: grid;
		grid-auto-columns: 1fr;
		grid-auto-flow: column;
		justify-items: center;
	}

	.layout-2 {
		grid-template-rows: 1fr;
		align-items: middle;
	}

	button, out {
		width: 2rem;
		height: 2rem;
		box-sizing: border-box;
		text-align: center;
		border: thin solid;
		margin: 0;
	}
</style>
